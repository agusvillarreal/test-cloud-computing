{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Tarea 2 — Gestión del Conocimiento\n",
        "# Implementación del Algoritmo BSAS\n",
        "\n",
        "**Nombre:** Agustín Villarreal\n",
        "\n",
        "**Correo:** agustin.villarreal0743@alumnos.udg.mx\n",
        "\n",
        "**Archivo:** bsas.ipynb"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Fundamento Teórico\n",
        "\n",
        "### BSAS (Basic Sequential Algorithmic Scheme)\n",
        "\n",
        "El algoritmo BSAS es un método de clustering secuencial que procesa vectores de características uno a la vez, tomando decisiones irrevocables sobre la asignación de cada patrón. El algoritmo fue propuesto originalmente por Tou en 1974.\n",
        "\n",
        "#### Parámetros principales:\n",
        "- **θ (theta)**: Umbral de disimilitud que determina si un patrón pertenece a un cluster existente\n",
        "- **q**: Número máximo de clusters permitidos\n",
        "\n",
        "#### Procedimiento del algoritmo:\n",
        "\n",
        "1. El primer patrón $\\mathbf{x}_1$ forma el primer cluster $C_1$ con representante $\\mathbf{m}_1 = \\mathbf{x}_1$\n",
        "\n",
        "2. Para cada patrón subsecuente $\\mathbf{x}_i$ ($i = 2, 3, ..., N$):\n",
        "   \n",
        "   a) Calcular la distancia mínima a todos los representantes existentes:\n",
        "   $$d_{min} = \\min_{j=1,...,K} d(\\mathbf{x}_i, \\mathbf{m}_j)$$\n",
        "   \n",
        "   b) Identificar el cluster más cercano $C_{winner}$\n",
        "   \n",
        "   c) **Si** $d_{min} \\leq \\theta$ **entonces**:\n",
        "      - Asignar $\\mathbf{x}_i$ al cluster $C_{winner}$\n",
        "      - Actualizar el representante: $\\mathbf{m}_{winner} = \\frac{n_{winner} \\cdot \\mathbf{m}_{winner} + \\mathbf{x}_i}{n_{winner} + 1}$\n",
        "   \n",
        "   d) **Si no, y** el número de clusters $K < q$ **entonces**:\n",
        "      - Crear nuevo cluster $C_{K+1}$ con $\\mathbf{m}_{K+1} = \\mathbf{x}_i$\n",
        "   \n",
        "   e) **Si no** (todos los clusters superan θ y $K = q$):\n",
        "      - Asignar $\\mathbf{x}_i$ al cluster más cercano de todas formas\n",
        "\n",
        "#### Métrica de distancia:\n",
        "En este trabajo utilizamos la distancia Euclidiana:\n",
        "$$d(\\mathbf{p}, \\mathbf{q}) = \\sqrt{\\sum_{i=1}^{d}(p_i - q_i)^2}$$\n",
        "\n",
        "#### Características del algoritmo:\n",
        "- **Complejidad temporal**: $O(N \\cdot K)$ donde $N$ es el número de patrones y $K \\leq q$\n",
        "- **Complejidad espacial**: $O(K \\cdot d)$ donde $d$ es la dimensionalidad\n",
        "- **Ventajas**: Simple, rápido, adecuado para flujo de datos (*streaming*)\n",
        "- **Desventajas**: Sensible al orden de presentación, decisiones irrevocables"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Importación de Librerías"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "import math\n",
        "import random\n",
        "import matplotlib.pyplot as plt\n",
        "from typing import List, Tuple\n",
        "\n",
        "%matplotlib inline"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Funciones Auxiliares"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "def calcular_distancia_euclidiana(punto1: Tuple[float, float], \n",
        "                                   punto2: Tuple[float, float]) -> float:\n",
        "    \"\"\"\n",
        "    Calcula la distancia euclidiana entre dos puntos en R^2.\n",
        "    \n",
        "    Parámetros:\n",
        "        punto1: Primera coordenada (x1, y1)\n",
        "        punto2: Segunda coordenada (x2, y2)\n",
        "    \n",
        "    Retorna:\n",
        "        Distancia euclidiana entre los puntos\n",
        "    \"\"\"\n",
        "    diferencia_x = punto1[0] - punto2[0]\n",
        "    diferencia_y = punto1[1] - punto2[1]\n",
        "    return math.sqrt(diferencia_x**2 + diferencia_y**2)\n",
        "\n",
        "\n",
        "def actualizar_representante(representante_actual: Tuple[float, float],\n",
        "                            tamaño_cluster: int,\n",
        "                            nuevo_punto: Tuple[float, float]) -> Tuple[float, float]:\n",
        "    \"\"\"\n",
        "    Actualiza el representante (centroide) de un cluster al añadir un nuevo punto.\n",
        "    Utiliza la fórmula de actualización incremental del promedio.\n",
        "    \n",
        "    Parámetros:\n",
        "        representante_actual: Centroide actual del cluster\n",
        "        tamaño_cluster: Número de puntos en el cluster antes de añadir el nuevo\n",
        "        nuevo_punto: Punto a añadir al cluster\n",
        "    \n",
        "    Retorna:\n",
        "        Nuevo centroide del cluster\n",
        "    \"\"\"\n",
        "    peso_actual = tamaño_cluster\n",
        "    peso_nuevo = tamaño_cluster + 1\n",
        "    \n",
        "    nueva_x = (peso_actual * representante_actual[0] + nuevo_punto[0]) / peso_nuevo\n",
        "    nueva_y = (peso_actual * representante_actual[1] + nuevo_punto[1]) / peso_nuevo\n",
        "    \n",
        "    return (nueva_x, nueva_y)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Implementación del Algoritmo BSAS"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "class AlgoritmoBSAS:\n",
        "    \"\"\"\n",
        "    Implementación del algoritmo BSAS (Basic Sequential Algorithmic Scheme)\n",
        "    para clustering de datos bidimensionales.\n",
        "    \n",
        "    El algoritmo procesa los datos secuencialmente y toma decisiones\n",
        "    irrevocables sobre la asignación de cada patrón a los clusters.\n",
        "    \"\"\"\n",
        "    \n",
        "    def __init__(self, theta: float, max_clusters: int):\n",
        "        \"\"\"\n",
        "        Inicializa el algoritmo BSAS.\n",
        "        \n",
        "        Parámetros:\n",
        "            theta: Umbral de disimilitud para asignar patrones a clusters\n",
        "            max_clusters: Número máximo de clusters permitidos (q)\n",
        "        \"\"\"\n",
        "        self.theta = theta\n",
        "        self.max_clusters = max_clusters\n",
        "        \n",
        "        # Estructuras de datos internas\n",
        "        self.representantes = []  # Lista de centroides de cada cluster\n",
        "        self.tamaños = []         # Número de elementos en cada cluster\n",
        "        self.etiquetas = []       # Asignación de cada patrón procesado\n",
        "        self.num_clusters_actual = 0\n",
        "    \n",
        "    def entrenar(self, patrones: List[Tuple[float, float]]) -> List[int]:\n",
        "        \"\"\"\n",
        "        Ejecuta el algoritmo BSAS sobre el conjunto de patrones.\n",
        "        \n",
        "        Parámetros:\n",
        "            patrones: Lista de tuplas (x, y) representando los puntos\n",
        "        \n",
        "        Retorna:\n",
        "            Lista de etiquetas de cluster para cada patrón\n",
        "        \"\"\"\n",
        "        # Reiniciar estructuras\n",
        "        self.representantes = []\n",
        "        self.tamaños = []\n",
        "        self.etiquetas = []\n",
        "        self.num_clusters_actual = 0\n",
        "        \n",
        "        if not patrones:\n",
        "            return self.etiquetas\n",
        "        \n",
        "        # Inicializar con el primer patrón\n",
        "        primer_patron = patrones[0]\n",
        "        self.representantes.append(primer_patron)\n",
        "        self.tamaños.append(1)\n",
        "        self.etiquetas.append(0)\n",
        "        self.num_clusters_actual = 1\n",
        "        \n",
        "        # Procesar patrones restantes secuencialmente\n",
        "        for patron in patrones[1:]:\n",
        "            self._procesar_patron(patron)\n",
        "        \n",
        "        return self.etiquetas\n",
        "    \n",
        "    def _procesar_patron(self, patron: Tuple[float, float]):\n",
        "        \"\"\"\n",
        "        Procesa un patrón individual según el algoritmo BSAS.\n",
        "        \n",
        "        Parámetros:\n",
        "            patron: Punto a procesar (x, y)\n",
        "        \"\"\"\n",
        "        # Paso 1: Encontrar el cluster más cercano\n",
        "        distancia_minima = float('inf')\n",
        "        indice_ganador = -1\n",
        "        \n",
        "        for idx, representante in enumerate(self.representantes):\n",
        "            distancia = calcular_distancia_euclidiana(patron, representante)\n",
        "            if distancia < distancia_minima:\n",
        "                distancia_minima = distancia\n",
        "                indice_ganador = idx\n",
        "        \n",
        "        # Paso 2: Tomar decisión según el umbral y número de clusters\n",
        "        if distancia_minima <= self.theta:\n",
        "            # Caso A: El patrón está suficientemente cerca, asignarlo\n",
        "            self._asignar_a_cluster_existente(patron, indice_ganador)\n",
        "        \n",
        "        elif self.num_clusters_actual < self.max_clusters:\n",
        "            # Caso B: Crear un nuevo cluster\n",
        "            self._crear_nuevo_cluster(patron)\n",
        "        \n",
        "        else:\n",
        "            # Caso C: Forzar asignación al cluster más cercano\n",
        "            self._asignar_a_cluster_existente(patron, indice_ganador)\n",
        "    \n",
        "    def _asignar_a_cluster_existente(self, patron: Tuple[float, float], \n",
        "                                     indice_cluster: int):\n",
        "        \"\"\"\n",
        "        Asigna un patrón a un cluster existente y actualiza su representante.\n",
        "        \"\"\"\n",
        "        # Actualizar representante con promedio incremental\n",
        "        representante_nuevo = actualizar_representante(\n",
        "            self.representantes[indice_cluster],\n",
        "            self.tamaños[indice_cluster],\n",
        "            patron\n",
        "        )\n",
        "        \n",
        "        self.representantes[indice_cluster] = representante_nuevo\n",
        "        self.tamaños[indice_cluster] += 1\n",
        "        self.etiquetas.append(indice_cluster)\n",
        "    \n",
        "    def _crear_nuevo_cluster(self, patron: Tuple[float, float]):\n",
        "        \"\"\"\n",
        "        Crea un nuevo cluster con el patrón dado como representante inicial.\n",
        "        \"\"\"\n",
        "        self.representantes.append(patron)\n",
        "        self.tamaños.append(1)\n",
        "        self.etiquetas.append(self.num_clusters_actual)\n",
        "        self.num_clusters_actual += 1\n",
        "    \n",
        "    def predecir(self, patrones_nuevos: List[Tuple[float, float]]) -> List[int]:\n",
        "        \"\"\"\n",
        "        Asigna nuevos patrones a los clusters existentes sin modificar\n",
        "        los representantes.\n",
        "        \n",
        "        Parámetros:\n",
        "            patrones_nuevos: Lista de puntos a clasificar\n",
        "        \n",
        "        Retorna:\n",
        "            Lista de etiquetas predichas\n",
        "        \"\"\"\n",
        "        predicciones = []\n",
        "        \n",
        "        for patron in patrones_nuevos:\n",
        "            distancia_minima = float('inf')\n",
        "            indice_predicho = 0\n",
        "            \n",
        "            for idx, representante in enumerate(self.representantes):\n",
        "                distancia = calcular_distancia_euclidiana(patron, representante)\n",
        "                if distancia < distancia_minima:\n",
        "                    distancia_minima = distancia\n",
        "                    indice_predicho = idx\n",
        "            \n",
        "            predicciones.append(indice_predicho)\n",
        "        \n",
        "        return predicciones\n",
        "    \n",
        "    def obtener_informacion_clusters(self):\n",
        "        \"\"\"\n",
        "        Retorna información sobre los clusters formados.\n",
        "        \"\"\"\n",
        "        info = {\n",
        "            'num_clusters': self.num_clusters_actual,\n",
        "            'representantes': self.representantes.copy(),\n",
        "            'tamaños': self.tamaños.copy()\n",
        "        }\n",
        "        return info"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Generación de Datos de Prueba"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "def generar_datos_sinteticos(semilla: int = 42) -> List[Tuple[float, float]]:\n",
        "    \"\"\"\n",
        "    Genera un conjunto de datos sintéticos con tres grupos gaussianos.\n",
        "    \n",
        "    Parámetros:\n",
        "        semilla: Semilla para reproducibilidad\n",
        "    \n",
        "    Retorna:\n",
        "        Lista de puntos 2D\n",
        "    \"\"\"\n",
        "    random.seed(semilla)\n",
        "    \n",
        "    # Configuración de tres grupos con diferentes características\n",
        "    configuracion_grupos = [\n",
        "        {'centro': (-3.0, 0.0), 'desviacion': 0.7, 'cantidad': 85},\n",
        "        {'centro': (3.0, 0.5), 'desviacion': 0.6, 'cantidad': 75},\n",
        "        {'centro': (0.0, 3.5), 'desviacion': 0.8, 'cantidad': 90}\n",
        "    ]\n",
        "    \n",
        "    datos_totales = []\n",
        "    \n",
        "    for config in configuracion_grupos:\n",
        "        centro_x, centro_y = config['centro']\n",
        "        sigma = config['desviacion']\n",
        "        n_puntos = config['cantidad']\n",
        "        \n",
        "        for _ in range(n_puntos):\n",
        "            x = random.gauss(centro_x, sigma)\n",
        "            y = random.gauss(centro_y, sigma)\n",
        "            datos_totales.append((x, y))\n",
        "    \n",
        "    return datos_totales\n",
        "\n",
        "\n",
        "# Generar conjunto de datos\n",
        "datos_experimentales = generar_datos_sinteticos()\n",
        "print(f\"Datos generados: {len(datos_experimentales)} puntos\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Experimento 1: Configuración Óptima"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Configurar parámetros\n",
        "THETA_OPTIMO = 1.3\n",
        "MAX_CLUSTERS = 5\n",
        "\n",
        "# Crear instancia y entrenar\n",
        "modelo_bsas = AlgoritmoBSAS(theta=THETA_OPTIMO, max_clusters=MAX_CLUSTERS)\n",
        "etiquetas_obtenidas = modelo_bsas.entrenar(datos_experimentales)\n",
        "\n",
        "# Obtener información de los clusters\n",
        "info = modelo_bsas.obtener_informacion_clusters()\n",
        "\n",
        "print(f\"\\n{'='*60}\")\n",
        "print(\"RESULTADOS DEL CLUSTERING BSAS\")\n",
        "print(f\"{'='*60}\")\n",
        "print(f\"Parámetros utilizados:\")\n",
        "print(f\"  - Theta (θ): {THETA_OPTIMO}\")\n",
        "print(f\"  - Máximo de clusters (q): {MAX_CLUSTERS}\")\n",
        "print(f\"\\nClusters formados: {info['num_clusters']}\")\n",
        "print(f\"\\nDistribución de patrones por cluster:\")\n",
        "\n",
        "for i in range(info['num_clusters']):\n",
        "    rep = info['representantes'][i]\n",
        "    tam = info['tamaños'][i]\n",
        "    print(f\"  Cluster {i}: {tam} patrones, centroide = ({rep[0]:.4f}, {rep[1]:.4f})\")\n",
        "\n",
        "print(f\"\\n{'='*60}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Visualización de Resultados"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "def visualizar_clustering(datos, etiquetas, representantes, titulo=\"Resultados BSAS\"):\n",
        "    \"\"\"\n",
        "    Visualiza los resultados del clustering.\n",
        "    \"\"\"\n",
        "    # Paleta de colores\n",
        "    paleta = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',\n",
        "              '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']\n",
        "    \n",
        "    num_clusters = len(representantes)\n",
        "    \n",
        "    plt.figure(figsize=(12, 8))\n",
        "    \n",
        "    # Graficar puntos por cluster\n",
        "    for k in range(num_clusters):\n",
        "        puntos_cluster = [(p[0], p[1]) for p, e in zip(datos, etiquetas) if e == k]\n",
        "        if puntos_cluster:\n",
        "            xs, ys = zip(*puntos_cluster)\n",
        "            plt.scatter(xs, ys, c=paleta[k % len(paleta)], \n",
        "                       s=25, alpha=0.6, label=f'Cluster {k} (n={len(puntos_cluster)})',\n",
        "                       edgecolors='none')\n",
        "    \n",
        "    # Graficar representantes\n",
        "    rep_x, rep_y = zip(*representantes)\n",
        "    plt.scatter(rep_x, rep_y, c='black', s=250, marker='*', \n",
        "               edgecolors='yellow', linewidths=2, \n",
        "               label='Representantes', zorder=5)\n",
        "    \n",
        "    plt.title(titulo, fontsize=14, fontweight='bold')\n",
        "    plt.xlabel('Dimensión X', fontsize=12)\n",
        "    plt.ylabel('Dimensión Y', fontsize=12)\n",
        "    plt.legend(loc='best', fontsize=10)\n",
        "    plt.grid(True, alpha=0.3, linestyle=':')\n",
        "    plt.tight_layout()\n",
        "    plt.show()\n",
        "\n",
        "\n",
        "visualizar_clustering(\n",
        "    datos_experimentales, \n",
        "    etiquetas_obtenidas, \n",
        "    info['representantes'],\n",
        "    f\"Clustering BSAS (θ={THETA_OPTIMO}, q={MAX_CLUSTERS})\"\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Experimento 2: Análisis de Sensibilidad del Parámetro θ"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Probar diferentes valores de theta\n",
        "valores_theta = [0.8, 1.3, 2.2]\n",
        "\n",
        "fig, axes = plt.subplots(1, 3, figsize=(18, 5))\n",
        "\n",
        "for idx, theta_test in enumerate(valores_theta):\n",
        "    # Entrenar modelo\n",
        "    modelo_test = AlgoritmoBSAS(theta=theta_test, max_clusters=MAX_CLUSTERS)\n",
        "    etiquetas_test = modelo_test.entrenar(datos_experimentales)\n",
        "    info_test = modelo_test.obtener_informacion_clusters()\n",
        "    \n",
        "    # Visualizar en subplot\n",
        "    ax = axes[idx]\n",
        "    paleta = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',\n",
        "              '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']\n",
        "    \n",
        "    for k in range(info_test['num_clusters']):\n",
        "        puntos = [(p[0], p[1]) for p, e in zip(datos_experimentales, etiquetas_test) if e == k]\n",
        "        if puntos:\n",
        "            xs, ys = zip(*puntos)\n",
        "            ax.scatter(xs, ys, c=paleta[k % len(paleta)], s=15, alpha=0.6)\n",
        "    \n",
        "    rep_x, rep_y = zip(*info_test['representantes'])\n",
        "    ax.scatter(rep_x, rep_y, c='black', s=180, marker='*', \n",
        "              edgecolors='yellow', linewidths=1.5, zorder=5)\n",
        "    \n",
        "    ax.set_title(f\"θ = {theta_test} (K = {info_test['num_clusters']})\", \n",
        "                fontsize=12, fontweight='bold')\n",
        "    ax.set_xlabel('X')\n",
        "    ax.set_ylabel('Y')\n",
        "    ax.grid(True, alpha=0.3, linestyle=':')\n",
        "\n",
        "plt.suptitle('Sensibilidad del Parámetro θ en BSAS', \n",
        "            fontsize=14, fontweight='bold', y=1.02)\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Experimento 3: Análisis del Orden de Presentación"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Probar con diferentes órdenes de los datos\n",
        "import copy\n",
        "\n",
        "# Orden original\n",
        "datos_orden1 = datos_experimentales.copy()\n",
        "\n",
        "# Orden aleatorio\n",
        "random.seed(100)\n",
        "datos_orden2 = datos_experimentales.copy()\n",
        "random.shuffle(datos_orden2)\n",
        "\n",
        "# Orden inverso\n",
        "datos_orden3 = datos_experimentales[::-1]\n",
        "\n",
        "ordenes = [\n",
        "    (datos_orden1, \"Original\"),\n",
        "    (datos_orden2, \"Aleatorio\"),\n",
        "    (datos_orden3, \"Inverso\")\n",
        "]\n",
        "\n",
        "fig, axes = plt.subplots(1, 3, figsize=(18, 5))\n",
        "\n",
        "for idx, (datos_orden, nombre_orden) in enumerate(ordenes):\n",
        "    modelo_orden = AlgoritmoBSAS(theta=THETA_OPTIMO, max_clusters=MAX_CLUSTERS)\n",
        "    etiquetas_orden = modelo_orden.entrenar(datos_orden)\n",
        "    info_orden = modelo_orden.obtener_informacion_clusters()\n",
        "    \n",
        "    ax = axes[idx]\n",
        "    paleta = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',\n",
        "              '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']\n",
        "    \n",
        "    for k in range(info_orden['num_clusters']):\n",
        "        puntos = [(p[0], p[1]) for p, e in zip(datos_orden, etiquetas_orden) if e == k]\n",
        "        if puntos:\n",
        "            xs, ys = zip(*puntos)\n",
        "            ax.scatter(xs, ys, c=paleta[k % len(paleta)], s=15, alpha=0.6)\n",
        "    \n",
        "    rep_x, rep_y = zip(*info_orden['representantes'])\n",
        "    ax.scatter(rep_x, rep_y, c='black', s=180, marker='*',\n",
        "              edgecolors='yellow', linewidths=1.5, zorder=5)\n",
        "    \n",
        "    ax.set_title(f\"Orden {nombre_orden} (K = {info_orden['num_clusters']})\",\n",
        "                fontsize=12, fontweight='bold')\n",
        "    ax.set_xlabel('X')\n",
        "    ax.set_ylabel('Y')\n",
        "    ax.grid(True, alpha=0.3, linestyle=':')\n",
        "\n",
        "plt.suptitle('Efecto del Orden de Presentación en BSAS',\n",
        "            fontsize=14, fontweight='bold', y=1.02)\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "print(\"\\nComparación de resultados según orden de presentación:\")\n",
        "for datos_orden, nombre_orden in ordenes:\n",
        "    modelo_comp = AlgoritmoBSAS(theta=THETA_OPTIMO, max_clusters=MAX_CLUSTERS)\n",
        "    modelo_comp.entrenar(datos_orden)\n",
        "    info_comp = modelo_comp.obtener_informacion_clusters()\n",
        "    print(f\"  {nombre_orden}: {info_comp['num_clusters']} clusters formados\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Conclusiones\n",
        "\n",
        "1. **Efectividad del algoritmo**: BSAS logra identificar estructuras naturales en los datos de manera eficiente.\n",
        "\n",
        "2. **Sensibilidad a θ**: El parámetro de umbral θ tiene un impacto significativo en el número de clusters formados:\n",
        "   - Valores pequeños generan más clusters (mayor granularidad)\n",
        "   - Valores grandes generan menos clusters (mayor agrupación)\n",
        "\n",
        "3. **Dependencia del orden**: Los resultados varían según el orden de presentación de los patrones, lo cual es una característica inherente de los algoritmos secuenciales.\n",
        "\n",
        "4. **Complejidad computacional**: El algoritmo mantiene complejidad lineal respecto al número de patrones, haciéndolo adecuado para grandes volúmenes de datos.\n",
        "\n",
        "5. **Aplicabilidad**: BSAS es particularmente útil en escenarios de procesamiento en tiempo real donde los datos llegan de forma secuencial."
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.13.5"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 4
}